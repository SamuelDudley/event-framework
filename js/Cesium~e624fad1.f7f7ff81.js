(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["Cesium~e624fad1"],{"0768":function(e,n,t){"use strict";n["a"]="varying vec3 v_positionEC;\nvarying vec3 v_normalEC;\nvarying vec2 v_st;\n\nvoid main()\n{\n    vec3 positionToEyeEC = -v_positionEC;\n\n    vec3 normalEC = normalize(v_normalEC);\n#ifdef FACE_FORWARD\n    normalEC = faceforward(normalEC, vec3(0.0, 0.0, 1.0), -normalEC);\n#endif\n\n    czm_materialInput materialInput;\n    materialInput.normalEC = normalEC;\n    materialInput.positionToEyeEC = positionToEyeEC;\n    materialInput.st = v_st;\n    czm_material material = czm_getMaterial(materialInput);\n\n#ifdef FLAT\n    gl_FragColor = vec4(material.diffuse + material.emission, material.alpha);\n#else\n    gl_FragColor = czm_phong(normalize(positionToEyeEC), material, czm_lightDirectionEC);\n#endif\n}\n"},"082a":function(e,n,t){"use strict";var o=t("535a"),i=t("2f63"),a=t("daa2"),r=t("ddf5"),s=t("a24f"),l=t("77d1"),c=t("38d6"),d=t("adba"),f=t("e349");function p(e,n){if(n=Object(o["a"])(n,o["a"].EMPTY_OBJECT),Object(i["a"])(e)&&Object(c["a"])(e,"KHR_materials_common")){Object(c["a"])(e,"KHR_techniques_webgl")||(Object(i["a"])(e.extensions)||(e.extensions={}),e.extensions.KHR_techniques_webgl={programs:[],shaders:[],techniques:[]},e.extensionsUsed.push("KHR_techniques_webgl"),e.extensionsRequired.push("KHR_techniques_webgl"));var t=e.extensions.KHR_techniques_webgl;g(e);var a=m(e),r=f["a"].splitIncompatibleMaterials(e),s={},d=!1;return l["a"].material(e,(function(o,l){if(Object(i["a"])(o.extensions)&&Object(i["a"])(o.extensions.KHR_materials_common)){var c=o.extensions.KHR_materials_common,f=r[l],p=_(c,f),m=s[p];Object(i["a"])(m)||(m=u(e,t,f,c,a,n.addBatchIdToGeneratedShaders),s[p]=m,d=!0);var v,g={},h=c.values;for(var b in h)h.hasOwnProperty(b)&&"transparent"!==b&&"doubleSided"!==b&&(v="u_"+b.toLowerCase(),g[v]=h[b]);o.extensions.KHR_techniques_webgl={technique:m,values:g},o.alphaMode="OPAQUE",c.transparent&&(o.alphaMode="BLEND"),c.doubleSided&&(o.doubleSided=!0)}})),d?(f["a"].ensureSemanticExistence(e),e):e}}function m(e){var n,t={};if(Object(i["a"])(e.extensions)&&Object(i["a"])(e.extensions.KHR_materials_common)&&(n=e.extensions.KHR_materials_common.lights),Object(i["a"])(n)){var o=e.nodes;for(var r in o)if(o.hasOwnProperty(r)){var s=o[r];if(Object(i["a"])(s.extensions)&&Object(i["a"])(s.extensions.KHR_materials_common)){var l=s.extensions.KHR_materials_common.light;Object(i["a"])(l)&&Object(i["a"])(n[l])&&(n[l].node=r),delete s.extensions.KHR_materials_common}}var c=0;for(var d in n)if(n.hasOwnProperty(d)){var f=n[d],p=f.type;if("ambient"!==p&&!Object(i["a"])(f.node)){delete n[d];continue}var m="light"+c.toString();switch(f.baseName=m,p){case"ambient":var u=f.ambient;t[m+"Color"]={type:a["a"].FLOAT_VEC3,value:u.color};break;case"directional":var v=f.directional;t[m+"Color"]={type:a["a"].FLOAT_VEC3,value:v.color},Object(i["a"])(f.node)&&(t[m+"Transform"]={node:f.node,semantic:"MODELVIEW",type:a["a"].FLOAT_MAT4});break;case"point":var _=f.point;t[m+"Color"]={type:a["a"].FLOAT_VEC3,value:_.color},Object(i["a"])(f.node)&&(t[m+"Transform"]={node:f.node,semantic:"MODELVIEW",type:a["a"].FLOAT_MAT4}),t[m+"Attenuation"]={type:a["a"].FLOAT_VEC3,value:[_.constantAttenuation,_.linearAttenuation,_.quadraticAttenuation]};break;case"spot":var g=f.spot;t[m+"Color"]={type:a["a"].FLOAT_VEC3,value:g.color},Object(i["a"])(f.node)&&(t[m+"Transform"]={node:f.node,semantic:"MODELVIEW",type:a["a"].FLOAT_MAT4},t[m+"InverseTransform"]={node:f.node,semantic:"MODELVIEWINVERSE",type:a["a"].FLOAT_MAT4,useInFragment:!0}),t[m+"Attenuation"]={type:a["a"].FLOAT_VEC3,value:[g.constantAttenuation,g.linearAttenuation,g.quadraticAttenuation]},t[m+"FallOff"]={type:a["a"].FLOAT_VEC2,value:[g.fallOffAngle,g.fallOffExponent]};break}++c}}return t}function u(e,n,t,l,p,m){Object(i["a"])(l)||(l={}),m=Object(o["a"])(m,!1);var u,_=n.techniques,g=n.shaders,h=n.programs,b=l.technique.toUpperCase();Object(i["a"])(e.extensions)&&Object(i["a"])(e.extensions.KHR_materials_common)&&(u=e.extensions.KHR_materials_common.lights);var C,T=l.values,x=Object(o["a"])(l.jointCount,0),E=!1,y=!1;Object(i["a"])(t)&&(C=t.skinning,E=C.skinned,y=t.hasVertexColors);var O,S="precision highp float;\n",I="precision highp float;\n",D="CONSTANT"!==b,F={u_modelViewMatrix:{semantic:Object(c["a"])(e,"CESIUM_RTC")?"CESIUM_RTC_MODELVIEW":"MODELVIEW",type:a["a"].FLOAT_MAT4},u_projectionMatrix:{semantic:"PROJECTION",type:a["a"].FLOAT_MAT4}};D&&(F.u_normalMatrix={semantic:"MODELVIEWINVERSETRANSPOSE",type:a["a"].FLOAT_MAT3}),E&&(F.u_jointMatrix={count:x,semantic:"JOINTMATRIX",type:a["a"].FLOAT_MAT4});var A=!1;for(var z in T)if(T.hasOwnProperty(z)&&"transparent"!==z&&"doubleSided"!==z){var H=v(z,T[z]);O="u_"+z.toLowerCase(),A||H!==a["a"].SAMPLER_2D||(A=!0),F[O]={type:H}}if(Object(i["a"])(F.u_diffuse)&&(F.u_diffuse.semantic="_3DTILESDIFFUSE"),Object(i["a"])(p))for(var L in p)p.hasOwnProperty(L)&&(O="u_"+L,F[O]=p[L]);for(O in F)if(F.hasOwnProperty(O)){var R=F[O],w=Object(i["a"])(R.count)?"["+R.count+"]":"";R.type!==a["a"].FLOAT_MAT3&&R.type!==a["a"].FLOAT_MAT4||R.useInFragment?(I+="uniform "+Object(r["a"])(R.type)+" "+O+w+";\n",delete R.useInFragment):S+="uniform "+Object(r["a"])(R.type)+" "+O+w+";\n"}var j="";if(E){var M,N,P=Object(d["a"])(C.type),G=!1;if(0===C.type.indexOf("MAT")&&(G=!0,P=Math.sqrt(P)),G)for(M=0;M<P;M++)for(N=0;N<P;N++)j+=0===M&&0===N?"  mat4 skinMat = ":"  skinMat += ",j+="a_weight["+M+"]["+N+"] * u_jointMatrix[int(a_joint["+M+"]["+N+"])];\n";else for(M=0;M<P;M++)j+=0===M?"  mat4 skinMat = ":"  skinMat += ",j+="a_weight["+M+"] * u_jointMatrix[int(a_joint["+M+"])];\n"}var V,B={a_position:{semantic:"POSITION"}};if(S+="attribute vec3 a_position;\n",S+="varying vec3 v_positionEC;\n",j+=E?"  vec4 pos = u_modelViewMatrix * skinMat * vec4(a_position,1.0);\n":"  vec4 pos = u_modelViewMatrix * vec4(a_position,1.0);\n",j+="  v_positionEC = pos.xyz;\n",j+="  gl_Position = u_projectionMatrix * pos;\n",I+="varying vec3 v_positionEC;\n",D&&(B.a_normal={semantic:"NORMAL"},S+="attribute vec3 a_normal;\n",S+="varying vec3 v_normal;\n",j+=E?"  v_normal = u_normalMatrix * mat3(skinMat) * a_normal;\n":"  v_normal = u_normalMatrix * a_normal;\n",I+="varying vec3 v_normal;\n"),A&&(B.a_texcoord_0={semantic:"TEXCOORD_0"},V="v_texcoord_0",S+="attribute vec2 a_texcoord_0;\n",S+="varying vec2 "+V+";\n",j+="  "+V+" = a_texcoord_0;\n",I+="varying vec2 "+V+";\n"),E){var W=f["a"].getShaderVariable(C.type);B.a_joint={semantic:"JOINT"},B.a_weight={semantic:"WEIGHT"},S+="attribute "+W+" a_joint;\n",S+="attribute "+W+" a_weight;\n"}y&&(B.a_vertexColor={semantic:"COLOR_0"},S+="attribute vec4 a_vertexColor;\n",S+="varying vec4 v_vertexColor;\n",j+="  v_vertexColor = a_vertexColor;\n",I+="varying vec4 v_vertexColor;\n"),m&&(B.a_batchId={semantic:"_BATCHID"},S+="attribute float a_batchId;\n");var k=D&&("BLINN"===b||"PHONG"===b)&&Object(i["a"])(F.u_specular)&&Object(i["a"])(F.u_shininess)&&F.u_shininess>0,U=!1,q=!1,K="";for(var X in u)if(u.hasOwnProperty(X)){var Y=u[X],J=Y.type.toLowerCase(),Z=Y.baseName;K+="  {\n";var Q,$,ee="u_"+Z+"Color";"ambient"===J?(q=!0,K+="    ambientLight += "+ee+";\n"):D&&(U=!0,Q="v_"+Z+"Direction",$="v_"+Z+"Position","point"!==J&&(S+="varying vec3 "+Q+";\n",I+="varying vec3 "+Q+";\n",j+="  "+Q+" = mat3(u_"+Z+"Transform) * vec3(0.,0.,1.);\n","directional"===J&&(K+="    vec3 l = normalize("+Q+");\n")),"directional"!==J?(S+="varying vec3 "+$+";\n",I+="varying vec3 "+$+";\n",j+="  "+$+" = u_"+Z+"Transform[3].xyz;\n",K+="    vec3 VP = "+$+" - v_positionEC;\n",K+="    vec3 l = normalize(VP);\n",K+="    float range = length(VP);\n",K+="    float attenuation = 1.0 / (u_"+Z+"Attenuation.x + ",K+="(u_"+Z+"Attenuation.y * range) + ",K+="(u_"+Z+"Attenuation.z * range * range));\n"):K+="    float attenuation = 1.0;\n","spot"===J&&(K+="    float spotDot = dot(l, normalize("+Q+"));\n",K+="    if (spotDot < cos(u_"+Z+"FallOff.x * 0.5))\n",K+="    {\n",K+="      attenuation = 0.0;\n",K+="    }\n",K+="    else\n",K+="    {\n",K+="        attenuation *= max(0.0, pow(spotDot, u_"+Z+"FallOff.y));\n",K+="    }\n"),K+="    diffuseLight += "+ee+"* max(dot(normal,l), 0.) * attenuation;\n",k&&("BLINN"===b?(K+="    vec3 h = normalize(l + viewDir);\n",K+="    float specularIntensity = max(0., pow(max(dot(normal, h), 0.), u_shininess)) * attenuation;\n"):(K+="    vec3 reflectDir = reflect(-l, normal);\n",K+="    float specularIntensity = max(0., pow(max(dot(reflectDir, viewDir), 0.), u_shininess)) * attenuation;\n"),K+="    specularLight += "+ee+" * specularIntensity;\n")),K+="  }\n"}if(q||(K+="  ambientLight += vec3(0.2, 0.2, 0.2);\n"),!U&&"CONSTANT"!==b){I+="#ifdef USE_CUSTOM_LIGHT_COLOR \n",I+="uniform vec3 gltf_lightColor; \n",I+="#endif \n",K+="#ifndef USE_CUSTOM_LIGHT_COLOR \n",K+="    vec3 lightColor = czm_lightColor;\n",K+="#else \n",K+="    vec3 lightColor = gltf_lightColor;\n",K+="#endif \n",K+="  vec3 l = normalize(czm_lightDirectionEC);\n";var ne="0.2";K+="  diffuseLight += lightColor * max(dot(normal,l), "+ne+");\n",k&&("BLINN"===b?(K+="  vec3 h = normalize(l + viewDir);\n",K+="  float specularIntensity = max(0., pow(max(dot(normal, h), 0.), u_shininess));\n"):(K+="  vec3 reflectDir = reflect(-l, normal);\n",K+="  float specularIntensity = max(0., pow(max(dot(reflectDir, viewDir), 0.), u_shininess));\n"),K+="  specularLight += lightColor * specularIntensity;\n")}S+="void main(void) {\n",S+=j,S+="}\n",I+="void main(void) {\n";var te,oe="  vec3 color = vec3(0.0, 0.0, 0.0);\n";D&&(I+="  vec3 normal = normalize(v_normal);\n",l.doubleSided&&(I+="  if (gl_FrontFacing == false)\n",I+="  {\n",I+="    normal = -normal;\n",I+="  }\n")),"CONSTANT"!==b?(Object(i["a"])(F.u_diffuse)&&(F.u_diffuse.type===a["a"].SAMPLER_2D?I+="  vec4 diffuse = texture2D(u_diffuse, "+V+");\n":I+="  vec4 diffuse = u_diffuse;\n",I+="  vec3 diffuseLight = vec3(0.0, 0.0, 0.0);\n",oe+="  color += diffuse.rgb * diffuseLight;\n"),k&&(F.u_specular.type===a["a"].SAMPLER_2D?I+="  vec3 specular = texture2D(u_specular, "+V+").rgb;\n":I+="  vec3 specular = u_specular.rgb;\n",I+="  vec3 specularLight = vec3(0.0, 0.0, 0.0);\n",oe+="  color += specular * specularLight;\n"),te=Object(i["a"])(F.u_transparency)?"  gl_FragColor = vec4(color * diffuse.a * u_transparency, diffuse.a * u_transparency);\n":"  gl_FragColor = vec4(color * diffuse.a, diffuse.a);\n"):te=Object(i["a"])(F.u_transparency)?"  gl_FragColor = vec4(color * u_transparency, u_transparency);\n":"  gl_FragColor = vec4(color, 1.0);\n",y&&(oe+="  color *= v_vertexColor.rgb;\n"),Object(i["a"])(F.u_emission)&&(F.u_emission.type===a["a"].SAMPLER_2D?I+="  vec3 emission = texture2D(u_emission, "+V+").rgb;\n":I+="  vec3 emission = u_emission.rgb;\n",oe+="  color += emission;\n"),(Object(i["a"])(F.u_ambient)||"CONSTANT"!==b)&&(Object(i["a"])(F.u_ambient)?F.u_ambient.type===a["a"].SAMPLER_2D?I+="  vec3 ambient = texture2D(u_ambient, "+V+").rgb;\n":I+="  vec3 ambient = u_ambient.rgb;\n":I+="  vec3 ambient = diffuse.rgb;\n",oe+="  color += ambient * ambientLight;\n"),I+="  vec3 viewDir = -normalize(v_positionEC);\n",I+="  vec3 ambientLight = vec3(0.0, 0.0, 0.0);\n",I+=K,I+=oe,I+=te,I+="}\n";var ie=Object(s["a"])(g,{type:a["a"].VERTEX_SHADER,extras:{_pipeline:{source:S,extension:".glsl"}}}),ae=Object(s["a"])(g,{type:a["a"].FRAGMENT_SHADER,extras:{_pipeline:{source:I,extension:".glsl"}}}),re=Object(s["a"])(h,{fragmentShader:ae,vertexShader:ie}),se=Object(s["a"])(_,{attributes:B,program:re,uniforms:F});return se}function v(e,n){var t;switch(t=Object(i["a"])(n.value)?n.value:Object(i["a"])(n.index)?[n.index]:n,e){case"ambient":return 1===t.length?a["a"].SAMPLER_2D:a["a"].FLOAT_VEC4;case"diffuse":return 1===t.length?a["a"].SAMPLER_2D:a["a"].FLOAT_VEC4;case"emission":return 1===t.length?a["a"].SAMPLER_2D:a["a"].FLOAT_VEC4;case"specular":return 1===t.length?a["a"].SAMPLER_2D:a["a"].FLOAT_VEC4;case"shininess":return a["a"].FLOAT;case"transparency":return a["a"].FLOAT;case"transparent":return a["a"].BOOL;case"doubleSided":return a["a"].BOOL}}function _(e,n){var t="";t+="technique:"+e.technique+";";for(var a=e.values,r=Object.keys(a).sort(),s=r.length,l=0;l<s;++l){var c=r[l];a.hasOwnProperty(c)&&(t+=c+":"+v(c,a[c]),t+=";")}var d=Object(o["a"])(e.jointCount,0);if(t+=d.toString()+";",Object(i["a"])(n)){var f=n.skinning;d>0&&(t+=f.type+";"),t+=n.hasVertexColors}return t}function g(e){var n=e.extensions.KHR_materials_common;if(Object(i["a"])(n)&&Object(i["a"])(n.lights))for(var t=n.lights,a=t.length,r=0;r<a;r++){var s=t[r];if("ambient"===s.type){Object(i["a"])(s.ambient)||(s.ambient={});var l=s.ambient;Object(i["a"])(l.color)||(l.color=[1,1,1])}else if("directional"===s.type){Object(i["a"])(s.directional)||(s.directional={});var c=s.directional;Object(i["a"])(c.color)||(c.color=[1,1,1])}else if("point"===s.type){Object(i["a"])(s.point)||(s.point={});var d=s.point;Object(i["a"])(d.color)||(d.color=[1,1,1]),d.constantAttenuation=Object(o["a"])(d.constantAttenuation,1),d.linearAttenuation=Object(o["a"])(d.linearAttenuation,0),d.quadraticAttenuation=Object(o["a"])(d.quadraticAttenuation,0)}else if("spot"===s.type){Object(i["a"])(s.spot)||(s.spot={});var f=s.spot;Object(i["a"])(f.color)||(f.color=[1,1,1]),f.constantAttenuation=Object(o["a"])(f.constantAttenuation,1),f.fallOffAngle=Object(o["a"])(f.fallOffAngle,3.14159265),f.fallOffExponent=Object(o["a"])(f.fallOffExponent,0),f.linearAttenuation=Object(o["a"])(f.linearAttenuation,0),f.quadraticAttenuation=Object(o["a"])(f.quadraticAttenuation,0)}}}n["a"]=p},"2c4b":function(e,n,t){"use strict";n["a"]="attribute vec3 position3DHigh;\nattribute vec3 position3DLow;\nattribute vec3 normal;\nattribute vec4 color;\nattribute float batchId;\n\nvarying vec3 v_positionEC;\nvarying vec3 v_normalEC;\nvarying vec4 v_color;\n\nvoid main()\n{\n    vec4 p = czm_computePosition();\n\n    v_positionEC = (czm_modelViewRelativeToEye * p).xyz;      // position in eye coordinates\n    v_normalEC = czm_normal * normal;                         // normal in eye coordinates\n    v_color = color;\n\n    gl_Position = czm_modelViewProjectionRelativeToEye * p;\n}\n"},"2d11":function(e,n,t){"use strict";n["a"]="attribute vec3 position3DHigh;\nattribute vec3 position3DLow;\nattribute vec3 normal;\nattribute float batchId;\n\nvarying vec3 v_positionEC;\nvarying vec3 v_normalEC;\n\nvoid main()\n{\n    vec4 p = czm_computePosition();\n\n    v_positionEC = (czm_modelViewRelativeToEye * p).xyz;      // position in eye coordinates\n    v_normalEC = czm_normal * normal;                         // normal in eye coordinates\n\n    gl_Position = czm_modelViewProjectionRelativeToEye * p;\n}\n"},"365a":function(e,n,t){"use strict";n["a"]="attribute vec3 position3DHigh;\nattribute vec3 position3DLow;\nattribute vec3 normal;\nattribute vec2 st;\nattribute float batchId;\n\nvarying vec3 v_positionEC;\nvarying vec3 v_normalEC;\nvarying vec2 v_st;\n\nvoid main()\n{\n    vec4 p = czm_computePosition();\n\n    v_positionEC = (czm_modelViewRelativeToEye * p).xyz;      // position in eye coordinates\n    v_normalEC = czm_normal * normal;                         // normal in eye coordinates\n    v_st = st;\n\n    gl_Position = czm_modelViewProjectionRelativeToEye * p;\n}\n"},"461c":function(e,n,t){"use strict";n["a"]="#ifdef MRT\n#extension GL_EXT_draw_buffers : enable\n#endif\n\nuniform vec4 u_bgColor;\nuniform sampler2D u_depthTexture;\n\nvarying vec2 v_textureCoordinates;\n\nvoid main()\n{\n    if (texture2D(u_depthTexture, v_textureCoordinates).r < 1.0)\n    {\n#ifdef MRT\n        gl_FragData[0] = u_bgColor;\n        gl_FragData[1] = vec4(u_bgColor.a);\n#else\n        gl_FragColor = u_bgColor;\n#endif\n        return;\n    }\n    \n    discard;\n}\n"},"60fc":function(e,n,t){"use strict";n["a"]="attribute vec3 position3DHigh;\nattribute vec3 position3DLow;\nattribute vec3 normal;\nattribute vec3 tangent;\nattribute vec3 bitangent;\nattribute vec2 st;\nattribute float batchId;\n\nvarying vec3 v_positionEC;\nvarying vec3 v_normalEC;\nvarying vec3 v_tangentEC;\nvarying vec3 v_bitangentEC;\nvarying vec2 v_st;\n\nvoid main()\n{\n    vec4 p = czm_computePosition();\n\n    v_positionEC = (czm_modelViewRelativeToEye * p).xyz;      // position in eye coordinates\n    v_normalEC = czm_normal * normal;                         // normal in eye coordinates\n    v_tangentEC = czm_normal * tangent;                       // tangent in eye coordinates\n    v_bitangentEC = czm_normal * bitangent;                   // bitangent in eye coordinates\n    v_st = st;\n\n    gl_Position = czm_modelViewProjectionRelativeToEye * p;\n}\n"},"6d53":function(e,n,t){"use strict";n["a"]='#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives : enable\n#endif\n\nuniform sampler2D u_atlas;\n\n#ifdef VECTOR_TILE\nuniform vec4 u_highlightColor;\n#endif\n\nvarying vec2 v_textureCoordinates;\nvarying vec4 v_pickColor;\nvarying vec4 v_color;\n\n#ifdef SDF\nvarying vec4 v_outlineColor;\nvarying float v_outlineWidth;\n#endif\n\n#ifdef FRAGMENT_DEPTH_CHECK\nvarying vec4 v_textureCoordinateBounds;                  // the min and max x and y values for the texture coordinates\nvarying vec4 v_originTextureCoordinateAndTranslate;      // texture coordinate at the origin, billboard translate (used for label glyphs)\nvarying vec4 v_compressed;                               // x: eyeDepth, y: applyTranslate & enableDepthCheck, z: dimensions, w: imageSize\nvarying mat2 v_rotationMatrix;\n\nconst float SHIFT_LEFT12 = 4096.0;\nconst float SHIFT_LEFT1 = 2.0;\n\nconst float SHIFT_RIGHT12 = 1.0 / 4096.0;\nconst float SHIFT_RIGHT1 = 1.0 / 2.0;\n\nfloat getGlobeDepth(vec2 adjustedST, vec2 depthLookupST, bool applyTranslate, vec2 dimensions, vec2 imageSize)\n{\n    vec2 lookupVector = imageSize * (depthLookupST - adjustedST);\n    lookupVector = v_rotationMatrix * lookupVector;\n    vec2 labelOffset = (dimensions - imageSize) * (depthLookupST - vec2(0.0, v_originTextureCoordinateAndTranslate.y)); // aligns label glyph with bounding rectangle.  Will be zero for billboards because dimensions and imageSize will be equal\n\n    vec2 translation = v_originTextureCoordinateAndTranslate.zw;\n\n    if (applyTranslate)\n    {\n        // this is only needed for labels where the horizontal origin is not LEFT\n        // it moves the label back to where the "origin" should be since all label glyphs are set to HorizontalOrigin.LEFT\n        translation += (dimensions * v_originTextureCoordinateAndTranslate.xy * vec2(1.0, 0.0));\n    }\n\n    vec2 st = ((lookupVector - translation + labelOffset) + gl_FragCoord.xy) / czm_viewport.zw;\n    float logDepthOrDepth = czm_unpackDepth(texture2D(czm_globeDepthTexture, st));\n\n    if (logDepthOrDepth == 0.0)\n    {\n        return 0.0; // not on the globe\n    }\n\n    vec4 eyeCoordinate = czm_windowToEyeCoordinates(gl_FragCoord.xy, logDepthOrDepth);\n    return eyeCoordinate.z / eyeCoordinate.w;\n}\n#endif\n\n\n#ifdef SDF\n\n// Get the distance from the edge of a glyph at a given position sampling an SDF texture.\nfloat getDistance(vec2 position)\n{\n    return texture2D(u_atlas, position).r;\n}\n\n// Samples the sdf texture at the given position and produces a color based on the fill color and the outline.\nvec4 getSDFColor(vec2 position, float outlineWidth, vec4 outlineColor, float smoothing)\n{\n    float distance = getDistance(position);\n\n    if (outlineWidth > 0.0)\n    {\n        // Don\'t get the outline edge exceed the SDF_EDGE\n        float outlineEdge = clamp(SDF_EDGE - outlineWidth, 0.0, SDF_EDGE);\n        float outlineFactor = smoothstep(SDF_EDGE - smoothing, SDF_EDGE + smoothing, distance);\n        vec4 sdfColor = mix(outlineColor, v_color, outlineFactor);\n        float alpha = smoothstep(outlineEdge - smoothing, outlineEdge + smoothing, distance);\n        return vec4(sdfColor.rgb, sdfColor.a * alpha);\n    }\n    else\n    {\n        float alpha = smoothstep(SDF_EDGE - smoothing, SDF_EDGE + smoothing, distance);\n        return vec4(v_color.rgb, v_color.a * alpha);\n    }\n}\n#endif\n\nvoid main()\n{\n    vec4 color = texture2D(u_atlas, v_textureCoordinates);\n\n#ifdef SDF\n    float outlineWidth = v_outlineWidth;\n    vec4 outlineColor = v_outlineColor;\n\n    // Get the current distance\n    float distance = getDistance(v_textureCoordinates);\n\n#ifdef GL_OES_standard_derivatives\n    float smoothing = fwidth(distance);\n    // Get an offset that is approximately half the distance to the neighbor pixels\n    // 0.354 is approximately half of 1/sqrt(2)\n    vec2 sampleOffset = 0.354 * vec2(dFdx(v_textureCoordinates) + dFdy(v_textureCoordinates));\n\n    // Sample the center point\n    vec4 center = getSDFColor(v_textureCoordinates, outlineWidth, outlineColor, smoothing);\n\n    // Sample the 4 neighbors\n    vec4 color1 = getSDFColor(v_textureCoordinates + vec2(sampleOffset.x, sampleOffset.y), outlineWidth, outlineColor, smoothing);\n    vec4 color2 = getSDFColor(v_textureCoordinates + vec2(-sampleOffset.x, sampleOffset.y), outlineWidth, outlineColor, smoothing);\n    vec4 color3 = getSDFColor(v_textureCoordinates + vec2(-sampleOffset.x, -sampleOffset.y), outlineWidth, outlineColor, smoothing);\n    vec4 color4 = getSDFColor(v_textureCoordinates + vec2(sampleOffset.x, -sampleOffset.y), outlineWidth, outlineColor, smoothing);\n\n    // Equally weight the center sample and the 4 neighboring samples\n    color = (center + color1 + color2 + color3 + color4)/5.0;\n#else\n    // Just do a single sample\n    float smoothing = 1.0/32.0;\n    color = getSDFColor(v_textureCoordinates, outlineWidth, outlineColor, smoothing);\n#endif\n\n    color = czm_gammaCorrect(color);\n#else\n    color = czm_gammaCorrect(color);\n    color *= czm_gammaCorrect(v_color);\n#endif\n\n// Fully transparent parts of the billboard are not pickable.\n#if !defined(OPAQUE) && !defined(TRANSLUCENT)\n    if (color.a < 0.005)   // matches 0/255 and 1/255\n    {\n        discard;\n    }\n#else\n// The billboard is rendered twice. The opaque pass discards translucent fragments\n// and the translucent pass discards opaque fragments.\n#ifdef OPAQUE\n    if (color.a < 0.995)   // matches < 254/255\n    {\n        discard;\n    }\n#else\n    if (color.a >= 0.995)  // matches 254/255 and 255/255\n    {\n        discard;\n    }\n#endif\n#endif\n\n#ifdef VECTOR_TILE\n    color *= u_highlightColor;\n#endif\n    gl_FragColor = color;\n\n    czm_writeLogDepth();\n\n#ifdef FRAGMENT_DEPTH_CHECK\n    float temp = v_compressed.y;\n\n    temp = temp * SHIFT_RIGHT1;\n\n    float temp2 = (temp - floor(temp)) * SHIFT_LEFT1;\n    bool enableDepthTest = temp2 != 0.0;\n    bool applyTranslate = floor(temp) != 0.0;\n\n    if (enableDepthTest) {\n        temp = v_compressed.z;\n        temp = temp * SHIFT_RIGHT12;\n\n        vec2 dimensions;\n        dimensions.y = (temp - floor(temp)) * SHIFT_LEFT12;\n        dimensions.x = floor(temp);\n\n        temp = v_compressed.w;\n        temp = temp * SHIFT_RIGHT12;\n\n        vec2 imageSize;\n        imageSize.y = (temp - floor(temp)) * SHIFT_LEFT12;\n        imageSize.x = floor(temp);\n\n        vec2 adjustedST = v_textureCoordinates - v_textureCoordinateBounds.xy;\n        adjustedST = adjustedST / vec2(v_textureCoordinateBounds.z - v_textureCoordinateBounds.x, v_textureCoordinateBounds.w - v_textureCoordinateBounds.y);\n\n        float epsilonEyeDepth = v_compressed.x + czm_epsilon1;\n        float globeDepth1 = getGlobeDepth(adjustedST, v_originTextureCoordinateAndTranslate.xy, applyTranslate, dimensions, imageSize);\n\n        // negative values go into the screen\n        if (globeDepth1 != 0.0 && globeDepth1 > epsilonEyeDepth)\n        {\n            float globeDepth2 = getGlobeDepth(adjustedST, vec2(0.0, 1.0), applyTranslate, dimensions, imageSize); // top left corner\n            if (globeDepth2 != 0.0 && globeDepth2 > epsilonEyeDepth)\n            {\n                float globeDepth3 = getGlobeDepth(adjustedST, vec2(1.0, 1.0), applyTranslate, dimensions, imageSize); // top right corner\n                if (globeDepth3 != 0.0 && globeDepth3 > epsilonEyeDepth)\n                {\n                    discard;\n                }\n            }\n        }\n    }\n#endif\n\n}\n'},"7be3":function(e,n,t){"use strict";n["a"]="attribute vec3 position3DHigh;\nattribute vec3 position3DLow;\nattribute vec3 prevPosition3DHigh;\nattribute vec3 prevPosition3DLow;\nattribute vec3 nextPosition3DHigh;\nattribute vec3 nextPosition3DLow;\nattribute vec2 expandAndWidth;\nattribute vec2 st;\nattribute float batchId;\n\nvarying float v_width;\nvarying vec2 v_st;\nvarying float v_polylineAngle;\n\nvoid main()\n{\n    float expandDir = expandAndWidth.x;\n    float width = abs(expandAndWidth.y) + 0.5;\n    bool usePrev = expandAndWidth.y < 0.0;\n\n    vec4 p = czm_computePosition();\n    vec4 prev = czm_computePrevPosition();\n    vec4 next = czm_computeNextPosition();\n\n    v_width = width;\n    v_st = st;\n\n    vec4 positionWC = getPolylineWindowCoordinates(p, prev, next, expandDir, width, usePrev, v_polylineAngle);\n    gl_Position = czm_viewportOrthographic * positionWC;\n\n#ifdef LOG_DEPTH\n    czm_vertexLogDepth(czm_modelViewProjectionRelativeToEye * p);\n#endif\n}\n"},"9c89":function(e,n,t){"use strict";n["a"]="attribute vec3 position3DHigh;\nattribute vec3 position3DLow;\nattribute vec4 color;\nattribute float batchId;\n\nvarying vec4 v_color;\n\nvoid main()\n{\n    vec4 p = czm_computePosition();\n\n    v_color = color;\n\n    gl_Position = czm_modelViewProjectionRelativeToEye * p;\n}\n"},"9ffa":function(e,n,t){"use strict";n["a"]="varying vec3 v_positionEC;\nvarying vec3 v_normalEC;\n\nvoid main()\n{\n    vec3 positionToEyeEC = -v_positionEC;\n\n    vec3 normalEC = normalize(v_normalEC);\n#ifdef FACE_FORWARD\n    normalEC = faceforward(normalEC, vec3(0.0, 0.0, 1.0), -normalEC);\n#endif\n\n    czm_materialInput materialInput;\n    materialInput.normalEC = normalEC;\n    materialInput.positionToEyeEC = positionToEyeEC;\n    czm_material material = czm_getMaterial(materialInput);\n\n#ifdef FLAT\n    gl_FragColor = vec4(material.diffuse + material.emission, material.alpha);\n#else\n    gl_FragColor = czm_phong(normalize(positionToEyeEC), material, czm_lightDirectionEC);\n#endif\n}\n"},a0fe:function(e,n,t){"use strict";n["a"]="attribute vec3 position3DHigh;\nattribute vec3 position3DLow;\nattribute vec3 prevPosition3DHigh;\nattribute vec3 prevPosition3DLow;\nattribute vec3 nextPosition3DHigh;\nattribute vec3 nextPosition3DLow;\nattribute vec2 expandAndWidth;\nattribute vec4 color;\nattribute float batchId;\n\nvarying vec4 v_color;\n\nvoid main()\n{\n    float expandDir = expandAndWidth.x;\n    float width = abs(expandAndWidth.y) + 0.5;\n    bool usePrev = expandAndWidth.y < 0.0;\n\n    vec4 p = czm_computePosition();\n    vec4 prev = czm_computePrevPosition();\n    vec4 next = czm_computeNextPosition();\n\n    v_color = color;\n\n    float angle;\n    vec4 positionWC = getPolylineWindowCoordinates(p, prev, next, expandDir, width, usePrev, angle);\n    gl_Position = czm_viewportOrthographic * positionWC;\n\n#ifdef LOG_DEPTH\n    czm_vertexLogDepth(czm_modelViewProjectionRelativeToEye * p);\n#endif\n}\n"},b6b6:function(e,n,t){"use strict";n["a"]="varying vec3 v_positionEC;\nvarying vec3 v_normalEC;\nvarying vec3 v_tangentEC;\nvarying vec3 v_bitangentEC;\nvarying vec2 v_st;\n\nvoid main()\n{\n    vec3 positionToEyeEC = -v_positionEC;\n    mat3 tangentToEyeMatrix = czm_tangentToEyeSpaceMatrix(v_normalEC, v_tangentEC, v_bitangentEC);\n\n    vec3 normalEC = normalize(v_normalEC);\n#ifdef FACE_FORWARD\n    normalEC = faceforward(normalEC, vec3(0.0, 0.0, 1.0), -normalEC);\n#endif\n\n    czm_materialInput materialInput;\n    materialInput.normalEC = normalEC;\n    materialInput.tangentToEyeMatrix = tangentToEyeMatrix;\n    materialInput.positionToEyeEC = positionToEyeEC;\n    materialInput.st = v_st;\n    czm_material material = czm_getMaterial(materialInput);\n\n#ifdef FLAT\n    gl_FragColor = vec4(material.diffuse + material.emission, material.alpha);\n#else\n    gl_FragColor = czm_phong(normalize(positionToEyeEC), material, czm_lightDirectionEC);\n#endif\n}\n"},d007:function(e,n,t){"use strict";var o=t("535a"),i=t("2f63"),a=t("daa2"),r=t("ddf5"),s=t("a24f"),l=t("77d1"),c=t("38d6"),d=t("adba"),f=t("e349");function p(e,n){if(n=Object(o["a"])(n,o["a"].EMPTY_OBJECT),Object(c["a"])(e,"KHR_techniques_webgl"))return e;if(!Object(i["a"])(e.materials)||0===e.materials.length)return e;Object(i["a"])(e.extensions)||(e.extensions={}),Object(i["a"])(e.extensionsUsed)||(e.extensionsUsed=[]),Object(i["a"])(e.extensionsRequired)||(e.extensionsRequired=[]),e.extensions.KHR_techniques_webgl={programs:[],shaders:[],techniques:[]},e.extensionsUsed.push("KHR_techniques_webgl"),e.extensionsRequired.push("KHR_techniques_webgl");var t=f["a"].splitIncompatibleMaterials(e);return l["a"].material(e,(function(o,a){var r={},s=b(e,o,a,r,t,n);Object(i["a"])(o.extensions)||(o.extensions={}),o.extensions.KHR_techniques_webgl={values:r,technique:s}})),f["a"].ensureSemanticExistence(e),e}function m(e){return Object(i["a"])(e.extensions)&&Object(i["a"])(e.extensions.KHR_materials_pbrSpecularGlossiness)}function u(e,n,t,o,a){var r;return Object(i["a"])(t[n+"Offset"])?(r=n+"Coord",a.fragmentShaderMain+="    vec2 "+r+" = computeTexCoord("+o+", "+n+"Offset, "+n+"Rotation, "+n+"Scale);\n"):r=o,r}var v=[0,0],_=[0],g=[1,1];function h(e,n,t){if(-1!==e.indexOf("Texture")&&Object(i["a"])(n.extensions)&&Object(i["a"])(n.extensions.KHR_texture_transform)){var a="u_"+e,r=n.extensions.KHR_texture_transform;t[a+"Offset"]=Object(o["a"])(r.offset,v),t[a+"Rotation"]=Object(o["a"])(r.rotation,_),t[a+"Scale"]=Object(o["a"])(r.scale,g),Object(i["a"])(n.texCoord)&&Object(i["a"])(r.texCoord)&&(t[a].texCoord=r.texCoord)}}function b(e,n,t,p,v,_){var g,b,T,x=Object(o["a"])(_.addBatchIdToGeneratedShaders,!1),E=e.extensions.KHR_techniques_webgl,y=E.techniques,O=E.shaders,S=E.programs,I=m(n),D=n.pbrMetallicRoughness;if(Object(i["a"])(D)&&!I)for(b in D)D.hasOwnProperty(b)&&(T=D[b],g="u_"+b,p[g]=T,h(b,T,p));if(I){var F=n.extensions.KHR_materials_pbrSpecularGlossiness;for(b in F)F.hasOwnProperty(b)&&(T=F[b],g="u_"+b,p[g]=T,h(b,T,p))}for(var A in n)n.hasOwnProperty(A)&&(A.indexOf("Texture")>=0||A.indexOf("Factor")>=0)&&(T=n[A],g="u_"+A,p[g]=T,h(A,T,p));var z,H="precision highp float;\n",L="precision highp float;\n";Object(i["a"])(e.skins)&&(z=e.skins[0]);var R,w,j=Object(i["a"])(z)?z.joints:[],M=j.length,N=v[t],P=!1,G=!1,V=!1,B=!1,W=!1,k=!1,U=!1;Object(i["a"])(N)&&(R=N.skinning,P=R.skinned&&j.length>0,G=N.hasVertexColors,V=N.hasMorphTargets,B=N.hasNormals,W=N.hasTangents,k=N.hasTexCoords),V&&l["a"].mesh(e,(function(e){l["a"].meshPrimitive(e,(function(e){if(e.material===t){var n=e.targets;Object(i["a"])(n)&&(w=n)}}))}));var q={u_modelViewMatrix:{semantic:Object(c["a"])(e,"CESIUM_RTC")?"CESIUM_RTC_MODELVIEW":"MODELVIEW",type:a["a"].FLOAT_MAT4},u_projectionMatrix:{semantic:"PROJECTION",type:a["a"].FLOAT_MAT4}};Object(i["a"])(n.extensions)&&Object(i["a"])(n.extensions.KHR_materials_unlit)&&(U=!0,B=!1,W=!1),B&&(q.u_normalMatrix={semantic:"MODELVIEWINVERSETRANSPOSE",type:a["a"].FLOAT_MAT3}),P&&(q.u_jointMatrix={count:M,semantic:"JOINTMATRIX",type:a["a"].FLOAT_MAT4}),V&&(q.u_morphWeights={count:w.length,semantic:"MORPHWEIGHTS",type:a["a"].FLOAT});var K=n.alphaMode;for(g in Object(i["a"])(K)&&"MASK"===K&&(q.u_alphaCutoff={semantic:"ALPHACUTOFF",type:a["a"].FLOAT}),p)p.hasOwnProperty(g)&&(q[g]={type:C(g)});var X=Object(o["a"])(q.u_baseColorTexture,q.u_baseColorFactor);for(g in Object(i["a"])(X)&&(X.semantic="_3DTILESDIFFUSE"),q)if(q.hasOwnProperty(g)){var Y=q[g],J=Object(i["a"])(Y.count)?"["+Y.count+"]":"";Y.type!==a["a"].FLOAT_MAT3&&Y.type!==a["a"].FLOAT_MAT4&&"u_morphWeights"!==g||Y.useInFragment?(L+="uniform "+Object(r["a"])(Y.type)+" "+g+J+";\n",delete Y.useInFragment):H+="uniform "+Object(r["a"])(Y.type)+" "+g+J+";\n"}var Z="";if(P){var Q,$,ee=Object(d["a"])(R.type),ne=!1;if(0===R.type.indexOf("MAT")&&(ne=!0,ee=Math.sqrt(ee)),ne)for(Q=0;Q<ee;Q++)for($=0;$<ee;$++)Z+=0===Q&&0===$?"    mat4 skinMatrix = ":"    skinMatrix += ",Z+="a_weight["+Q+"]["+$+"] * u_jointMatrix[int(a_joint["+Q+"]["+$+"])];\n";else for(Q=0;Q<ee;Q++)Z+=0===Q?"    mat4 skinMatrix = ":"    skinMatrix += ",Z+="a_weight["+Q+"] * u_jointMatrix[int(a_joint["+Q+"])];\n"}var te={a_position:{semantic:"POSITION"}};if(H+="attribute vec3 a_position;\n",B&&(H+="varying vec3 v_positionEC;\n"),Z+="    vec3 weightedPosition = a_position;\n",B&&(Z+="    vec3 weightedNormal = a_normal;\n"),W&&(Z+="    vec4 weightedTangent = a_tangent;\n"),V)for(var oe=0;oe<w.length;oe++){var ie=w[oe];for(var ae in ie)if(ie.hasOwnProperty(ae)&&"extras"!==ae){var re="a_"+ae+"_"+oe;te[re]={semantic:ae+"_"+oe},H+="attribute vec3 "+re+";\n","POSITION"===ae?Z+="    weightedPosition += u_morphWeights["+oe+"] * "+re+";\n":"NORMAL"===ae?Z+="    weightedNormal += u_morphWeights["+oe+"] * "+re+";\n":W&&"TANGENT"===ae&&(Z+="    weightedTangent.xyz += u_morphWeights["+oe+"] * "+re+";\n")}}Z+=P?"    vec4 position = skinMatrix * vec4(weightedPosition, 1.0);\n":"    vec4 position = vec4(weightedPosition, 1.0);\n",Z+="    position = u_modelViewMatrix * position;\n",B&&(Z+="    v_positionEC = position.xyz;\n"),Z+="    gl_Position = u_projectionMatrix * position;\n",B&&(te.a_normal={semantic:"NORMAL"},H+="attribute vec3 a_normal;\n",H+="varying vec3 v_normal;\n",Z+=P?"    v_normal = u_normalMatrix * mat3(skinMatrix) * weightedNormal;\n":"    v_normal = u_normalMatrix * weightedNormal;\n",L+="varying vec3 v_normal;\n",L+="varying vec3 v_positionEC;\n"),W&&(te.a_tangent={semantic:"TANGENT"},H+="attribute vec4 a_tangent;\n",H+="varying vec4 v_tangent;\n",Z+="    v_tangent.xyz = u_normalMatrix * weightedTangent.xyz;\n",Z+="    v_tangent.w = weightedTangent.w;\n",L+="varying vec4 v_tangent;\n");var se,le,ce,de,fe,pe,me,ue,ve="";if(k){te.a_texcoord_0={semantic:"TEXCOORD_0"},se="v_texcoord_0",H+="attribute vec2 a_texcoord_0;\n",H+="varying vec2 "+se+";\n",Z+="    "+se+" = a_texcoord_0;\n",L+="varying vec2 "+se+";\n";var _e={fragmentShaderMain:ve};le=u(e,"u_normalTexture",p,se,_e),ce=u(e,"u_baseColorTexture",p,se,_e),de=u(e,"u_specularGlossinessTexture",p,se,_e),fe=u(e,"u_diffuseTexture",p,se,_e),pe=u(e,"u_metallicRoughnessTexture",p,se,_e),me=u(e,"u_occlusionTexture",p,se,_e),ue=u(e,"u_emmissiveTexture",p,se,_e),ve=_e.fragmentShaderMain}if(P){var ge=f["a"].getShaderVariable(R.type);te.a_joint={semantic:"JOINTS_0"},te.a_weight={semantic:"WEIGHTS_0"},H+="attribute "+ge+" a_joint;\n",H+="attribute "+ge+" a_weight;\n"}G&&(te.a_vertexColor={semantic:"COLOR_0"},H+="attribute vec4 a_vertexColor;\n",H+="varying vec4 v_vertexColor;\n",Z+="  v_vertexColor = a_vertexColor;\n",L+="varying vec4 v_vertexColor;\n"),x&&(te.a_batchId={semantic:"_BATCHID"},H+="attribute float a_batchId;\n"),H+="void main(void) \n{\n",H+=Z,H+="}\n",B&&(L+="const float M_PI = 3.141592653589793;\n",L+="vec3 lambertianDiffuse(vec3 diffuseColor) \n{\n    return diffuseColor / M_PI;\n}\n\n",L+="vec3 fresnelSchlick2(vec3 f0, vec3 f90, float VdotH) \n{\n    return f0 + (f90 - f0) * pow(clamp(1.0 - VdotH, 0.0, 1.0), 5.0);\n}\n\n",L+="vec3 fresnelSchlick(float metalness, float VdotH) \n{\n    return metalness + (vec3(1.0) - metalness) * pow(1.0 - VdotH, 5.0);\n}\n\n",L+="float smithVisibilityG1(float NdotV, float roughness) \n{\n    float k = (roughness + 1.0) * (roughness + 1.0) / 8.0;\n    return NdotV / (NdotV * (1.0 - k) + k);\n}\n\n",L+="float smithVisibilityGGX(float roughness, float NdotL, float NdotV) \n{\n    return smithVisibilityG1(NdotL, roughness) * smithVisibilityG1(NdotV, roughness);\n}\n\n",L+="float GGX(float roughness, float NdotH) \n{\n    float roughnessSquared = roughness * roughness;\n    float f = (NdotH * roughnessSquared - NdotH) * NdotH + 1.0;\n    return roughnessSquared / (M_PI * f * f);\n}\n\n"),L+="vec3 SRGBtoLINEAR3(vec3 srgbIn) \n{\n    return pow(srgbIn, vec3(2.2));\n}\n\n",L+="vec4 SRGBtoLINEAR4(vec4 srgbIn) \n{\n    vec3 linearOut = pow(srgbIn.rgb, vec3(2.2));\n    return vec4(linearOut, srgbIn.a);\n}\n\n",L+="vec3 applyTonemapping(vec3 linearIn) \n{\n#ifndef HDR \n    return czm_acesTonemapping(linearIn);\n#else \n    return linearIn;\n#endif \n}\n\n",L+="vec3 LINEARtoSRGB(vec3 linearIn) \n{\n#ifndef HDR \n    return pow(linearIn, vec3(1.0/2.2));\n#else \n    return linearIn;\n#endif \n}\n\n",L+="vec2 computeTexCoord(vec2 texCoords, vec2 offset, float rotation, vec2 scale) \n{\n    rotation = -rotation; \n    mat3 transform = mat3(\n        cos(rotation) * scale.x, sin(rotation) * scale.x, 0.0, \n       -sin(rotation) * scale.y, cos(rotation) * scale.y, 0.0, \n        offset.x, offset.y, 1.0); \n    vec2 transformedTexCoords = (transform * vec3(fract(texCoords), 1.0)).xy; \n    return transformedTexCoords; \n}\n\n",L+="#ifdef USE_IBL_LIGHTING \n",L+="uniform vec2 gltf_iblFactor; \n",L+="#endif \n",L+="#ifdef USE_CUSTOM_LIGHT_COLOR \n",L+="uniform vec3 gltf_lightColor; \n",L+="#endif \n",L+="void main(void) \n{\n",L+=ve,B&&(L+="    vec3 ng = normalize(v_normal);\n",L+="    vec3 positionWC = vec3(czm_inverseView * vec4(v_positionEC, 1.0));\n",Object(i["a"])(p.u_normalTexture)?W?(L+="    vec3 t = normalize(v_tangent.xyz);\n",L+="    vec3 b = normalize(cross(ng, t) * v_tangent.w);\n",L+="    mat3 tbn = mat3(t, b, ng);\n",L+="    vec3 n = texture2D(u_normalTexture, "+le+").rgb;\n",L+="    n = normalize(tbn * (2.0 * n - 1.0));\n"):(L="#ifdef GL_OES_standard_derivatives\n#extension GL_OES_standard_derivatives : enable\n#endif\n"+L,L+="#ifdef GL_OES_standard_derivatives\n",L+="    vec3 pos_dx = dFdx(v_positionEC);\n",L+="    vec3 pos_dy = dFdy(v_positionEC);\n",L+="    vec3 tex_dx = dFdx(vec3("+le+",0.0));\n",L+="    vec3 tex_dy = dFdy(vec3("+le+",0.0));\n",L+="    vec3 t = (tex_dy.t * pos_dx - tex_dx.t * pos_dy) / (tex_dx.s * tex_dy.t - tex_dy.s * tex_dx.t);\n",L+="    t = normalize(t - ng * dot(ng, t));\n",L+="    vec3 b = normalize(cross(ng, t));\n",L+="    mat3 tbn = mat3(t, b, ng);\n",L+="    vec3 n = texture2D(u_normalTexture, "+le+").rgb;\n",L+="    n = normalize(tbn * (2.0 * n - 1.0));\n",L+="#else\n",L+="    vec3 n = ng;\n",L+="#endif\n"):L+="    vec3 n = ng;\n",n.doubleSided&&(L+="    if (gl_FrontFacing == false)\n",L+="    {\n",L+="        n = -n;\n",L+="    }\n")),Object(i["a"])(p.u_baseColorTexture)?(L+="    vec4 baseColorWithAlpha = SRGBtoLINEAR4(texture2D(u_baseColorTexture, "+ce+"));\n",Object(i["a"])(p.u_baseColorFactor)&&(L+="    baseColorWithAlpha *= u_baseColorFactor;\n")):Object(i["a"])(p.u_baseColorFactor)?L+="    vec4 baseColorWithAlpha = u_baseColorFactor;\n":L+="    vec4 baseColorWithAlpha = vec4(1.0);\n",G&&(L+="    baseColorWithAlpha *= v_vertexColor;\n"),L+="    vec3 baseColor = baseColorWithAlpha.rgb;\n",B?(I?(Object(i["a"])(p.u_specularGlossinessTexture)?(L+="    vec4 specularGlossiness = SRGBtoLINEAR4(texture2D(u_specularGlossinessTexture, "+de+"));\n",L+="    vec3 specular = specularGlossiness.rgb;\n",L+="    float glossiness = specularGlossiness.a;\n",Object(i["a"])(p.u_specularFactor)&&(L+="    specular *= u_specularFactor;\n"),Object(i["a"])(p.u_glossinessFactor)&&(L+="    glossiness *= u_glossinessFactor;\n")):(Object(i["a"])(p.u_specularFactor)?L+="    vec3 specular = clamp(u_specularFactor, vec3(0.0), vec3(1.0));\n":L+="    vec3 specular = vec3(1.0);\n",Object(i["a"])(p.u_glossinessFactor)?L+="    float glossiness = clamp(u_glossinessFactor, 0.0, 1.0);\n":L+="    float glossiness = 1.0;\n"),Object(i["a"])(p.u_diffuseTexture)?(L+="    vec4 diffuse = SRGBtoLINEAR4(texture2D(u_diffuseTexture, "+fe+"));\n",Object(i["a"])(p.u_diffuseFactor)&&(L+="    diffuse *= u_diffuseFactor;\n")):Object(i["a"])(p.u_diffuseFactor)?L+="    vec4 diffuse = clamp(u_diffuseFactor, vec4(0.0), vec4(1.0));\n":L+="    vec4 diffuse = vec4(1.0);\n"):Object(i["a"])(p.u_metallicRoughnessTexture)?(L+="    vec3 metallicRoughness = texture2D(u_metallicRoughnessTexture, "+pe+").rgb;\n",L+="    float metalness = clamp(metallicRoughness.b, 0.0, 1.0);\n",L+="    float roughness = clamp(metallicRoughness.g, 0.04, 1.0);\n",Object(i["a"])(p.u_metallicFactor)&&(L+="    metalness *= u_metallicFactor;\n"),Object(i["a"])(p.u_roughnessFactor)&&(L+="    roughness *= u_roughnessFactor;\n")):(Object(i["a"])(p.u_metallicFactor)?L+="    float metalness = clamp(u_metallicFactor, 0.0, 1.0);\n":L+="    float metalness = 1.0;\n",Object(i["a"])(p.u_roughnessFactor)?L+="    float roughness = clamp(u_roughnessFactor, 0.04, 1.0);\n":L+="    float roughness = 1.0;\n"),L+="    vec3 v = -normalize(v_positionEC);\n",L+="#ifndef USE_CUSTOM_LIGHT_COLOR \n",L+="    vec3 lightColorHdr = czm_lightColorHdr;\n",L+="#else \n",L+="    vec3 lightColorHdr = gltf_lightColor;\n",L+="#endif \n",L+="    vec3 l = normalize(czm_lightDirectionEC);\n",L+="    vec3 h = normalize(v + l);\n",L+="    float NdotL = clamp(dot(n, l), 0.001, 1.0);\n",L+="    float NdotV = abs(dot(n, v)) + 0.001;\n",L+="    float NdotH = clamp(dot(n, h), 0.0, 1.0);\n",L+="    float LdotH = clamp(dot(l, h), 0.0, 1.0);\n",L+="    float VdotH = clamp(dot(v, h), 0.0, 1.0);\n",L+="    vec3 f0 = vec3(0.04);\n",I?(L+="    float roughness = 1.0 - glossiness;\n",L+="    vec3 diffuseColor = diffuse.rgb * (1.0 - max(max(specular.r, specular.g), specular.b));\n",L+="    vec3 specularColor = specular;\n"):(L+="    vec3 diffuseColor = baseColor * (1.0 - metalness) * (1.0 - f0);\n",L+="    vec3 specularColor = mix(f0, baseColor, metalness);\n"),L+="    float alpha = roughness * roughness;\n",L+="    float reflectance = max(max(specularColor.r, specularColor.g), specularColor.b);\n",L+="    vec3 r90 = vec3(clamp(reflectance * 25.0, 0.0, 1.0));\n",L+="    vec3 r0 = specularColor.rgb;\n",L+="    vec3 F = fresnelSchlick2(r0, r90, VdotH);\n",L+="    float G = smithVisibilityGGX(alpha, NdotL, NdotV);\n",L+="    float D = GGX(alpha, NdotH);\n",L+="    vec3 diffuseContribution = (1.0 - F) * lambertianDiffuse(diffuseColor);\n",L+="    vec3 specularContribution = F * G * D / (4.0 * NdotL * NdotV);\n",L+="    vec3 color = NdotL * lightColorHdr * (diffuseContribution + specularContribution);\n",L+="#if defined(USE_IBL_LIGHTING) && !defined(DIFFUSE_IBL) && !defined(SPECULAR_IBL) \n",L+="    vec3 r = normalize(czm_inverseViewRotation * normalize(reflect(v, n)));\n",L+="    float vertexRadius = length(positionWC);\n",L+="    float horizonDotNadir = 1.0 - min(1.0, czm_ellipsoidRadii.x / vertexRadius);\n",L+="    float reflectionDotNadir = dot(r, normalize(positionWC));\n",L+="    r.x = -r.x;\n",L+="    r = -normalize(czm_temeToPseudoFixed * r);\n",L+="    r.x = -r.x;\n",L+="    float inverseRoughness = 1.04 - roughness;\n",L+="    inverseRoughness *= inverseRoughness;\n",L+="    vec3 sceneSkyBox = textureCube(czm_environmentMap, r).rgb * inverseRoughness;\n",L+="    float atmosphereHeight = 0.05;\n",L+="    float blendRegionSize = 0.1 * ((1.0 - inverseRoughness) * 8.0 + 1.1 - horizonDotNadir);\n",L+="    float blendRegionOffset = roughness * -1.0;\n",L+="    float farAboveHorizon = clamp(horizonDotNadir - blendRegionSize * 0.5 + blendRegionOffset, 1.0e-10 - blendRegionSize, 0.99999);\n",L+="    float aroundHorizon = clamp(horizonDotNadir + blendRegionSize * 0.5, 1.0e-10 - blendRegionSize, 0.99999);\n",L+="    float farBelowHorizon = clamp(horizonDotNadir + blendRegionSize * 1.5, 1.0e-10 - blendRegionSize, 0.99999);\n",L+="    float smoothstepHeight = smoothstep(0.0, atmosphereHeight, horizonDotNadir);\n",L+="    vec3 belowHorizonColor = mix(vec3(0.1, 0.15, 0.25), vec3(0.4, 0.7, 0.9), smoothstepHeight);\n",L+="    vec3 nadirColor = belowHorizonColor * 0.5;\n",L+="    vec3 aboveHorizonColor = mix(vec3(0.9, 1.0, 1.2), belowHorizonColor, roughness * 0.5);\n",L+="    vec3 blueSkyColor = mix(vec3(0.18, 0.26, 0.48), aboveHorizonColor, reflectionDotNadir * inverseRoughness * 0.5 + 0.75);\n",L+="    vec3 zenithColor = mix(blueSkyColor, sceneSkyBox, smoothstepHeight);\n",L+="    vec3 blueSkyDiffuseColor = vec3(0.7, 0.85, 0.9);\n",L+="    float diffuseIrradianceFromEarth = (1.0 - horizonDotNadir) * (reflectionDotNadir * 0.25 + 0.75) * smoothstepHeight;\n",L+="    float diffuseIrradianceFromSky = (1.0 - smoothstepHeight) * (1.0 - (reflectionDotNadir * 0.25 + 0.25));\n",L+="    vec3 diffuseIrradiance = blueSkyDiffuseColor * clamp(diffuseIrradianceFromEarth + diffuseIrradianceFromSky, 0.0, 1.0);\n",L+="    float notDistantRough = (1.0 - horizonDotNadir * roughness * 0.8);\n",L+="    vec3 specularIrradiance = mix(zenithColor, aboveHorizonColor, smoothstep(farAboveHorizon, aroundHorizon, reflectionDotNadir) * notDistantRough);\n",L+="    specularIrradiance = mix(specularIrradiance, belowHorizonColor, smoothstep(aroundHorizon, farBelowHorizon, reflectionDotNadir) * inverseRoughness);\n",L+="    specularIrradiance = mix(specularIrradiance, nadirColor, smoothstep(farBelowHorizon, 1.0, reflectionDotNadir) * inverseRoughness);\n",L+="#ifdef USE_SUN_LUMINANCE \n",L+="    float LdotZenith = clamp(dot(normalize(czm_inverseViewRotation * l), normalize(positionWC * -1.0)), 0.001, 1.0);\n",L+="    float S = acos(LdotZenith);\n",L+="    float NdotZenith = clamp(dot(normalize(czm_inverseViewRotation * n), normalize(positionWC * -1.0)), 0.001, 1.0);\n",L+="    float gamma = acos(NdotL);\n",L+="    float numerator = ((0.91 + 10.0 * exp(-3.0 * gamma) + 0.45 * pow(NdotL, 2.0)) * (1.0 - exp(-0.32 / NdotZenith)));\n",L+="    float denominator = (0.91 + 10.0 * exp(-3.0 * S) + 0.45 * pow(LdotZenith,2.0)) * (1.0 - exp(-0.32));\n",L+="    float luminance = gltf_luminanceAtZenith * (numerator / denominator);\n",L+="#endif \n",L+="    vec2 brdfLut = texture2D(czm_brdfLut, vec2(NdotV, roughness)).rg;\n",L+="    vec3 IBLColor = (diffuseIrradiance * diffuseColor * gltf_iblFactor.x) + (specularIrradiance * SRGBtoLINEAR3(specularColor * brdfLut.x + brdfLut.y) * gltf_iblFactor.y);\n",L+="    float maximumComponent = max(max(lightColorHdr.x, lightColorHdr.y), lightColorHdr.z);\n",L+="    vec3 lightColor = lightColorHdr / max(maximumComponent, 1.0);\n",L+="    IBLColor *= lightColor;\n",L+="#ifdef USE_SUN_LUMINANCE \n",L+="    color += IBLColor * luminance;\n",L+="#else \n",L+="    color += IBLColor; \n",L+="#endif \n",L+="#elif defined(DIFFUSE_IBL) || defined(SPECULAR_IBL) \n",L+="    mat3 fixedToENU = mat3(gltf_clippingPlanesMatrix[0][0], gltf_clippingPlanesMatrix[1][0], gltf_clippingPlanesMatrix[2][0], \n",L+="                           gltf_clippingPlanesMatrix[0][1], gltf_clippingPlanesMatrix[1][1], gltf_clippingPlanesMatrix[2][1], \n",L+="                           gltf_clippingPlanesMatrix[0][2], gltf_clippingPlanesMatrix[1][2], gltf_clippingPlanesMatrix[2][2]); \n",L+="    const mat3 yUpToZUp = mat3(-1.0, 0.0, 0.0, 0.0, 0.0, -1.0, 0.0, 1.0, 0.0); \n",L+="    vec3 cubeDir = normalize(yUpToZUp * fixedToENU * normalize(reflect(-v, n))); \n",L+="#ifdef DIFFUSE_IBL \n",L+="#ifdef CUSTOM_SPHERICAL_HARMONICS \n",L+="    vec3 diffuseIrradiance = czm_sphericalHarmonics(cubeDir, gltf_sphericalHarmonicCoefficients); \n",L+="#else \n",L+="    vec3 diffuseIrradiance = czm_sphericalHarmonics(cubeDir, czm_sphericalHarmonicCoefficients); \n",L+="#endif \n",L+="#else \n",L+="    vec3 diffuseIrradiance = vec3(0.0); \n",L+="#endif \n",L+="#ifdef SPECULAR_IBL \n",L+="    vec2 brdfLut = texture2D(czm_brdfLut, vec2(NdotV, roughness)).rg;\n",L+="#ifdef CUSTOM_SPECULAR_IBL \n",L+="    vec3 specularIBL = czm_sampleOctahedralProjection(gltf_specularMap, gltf_specularMapSize, cubeDir,  roughness * gltf_maxSpecularLOD, gltf_maxSpecularLOD);\n",L+="#else \n",L+="    vec3 specularIBL = czm_sampleOctahedralProjection(czm_specularEnvironmentMaps, czm_specularEnvironmentMapSize, cubeDir,  roughness * czm_specularEnvironmentMapsMaximumLOD, czm_specularEnvironmentMapsMaximumLOD);\n",L+="#endif \n",L+="    specularIBL *= F * brdfLut.x + brdfLut.y;\n",L+="#else \n",L+="    vec3 specularIBL = vec3(0.0); \n",L+="#endif \n",L+="    color += diffuseIrradiance * diffuseColor + specularColor * specularIBL;\n",L+="#endif \n"):L+="    vec3 color = baseColor;\n",U||(Object(i["a"])(p.u_occlusionTexture)&&(L+="    color *= texture2D(u_occlusionTexture, "+me+").r;\n"),Object(i["a"])(p.u_emissiveTexture)?(L+="    vec3 emissive = SRGBtoLINEAR3(texture2D(u_emissiveTexture, "+ue+").rgb);\n",Object(i["a"])(p.u_emissiveFactor)&&(L+="    emissive *= u_emissiveFactor;\n"),L+="    color += emissive;\n"):Object(i["a"])(p.u_emissiveFactor)&&(L+="    color += u_emissiveFactor;\n")),U||(L+="    color = applyTonemapping(color);\n"),L+="    color = LINEARtoSRGB(color);\n",Object(i["a"])(K)?"MASK"===K?(L+="    if (baseColorWithAlpha.a < u_alphaCutoff) {\n",L+="        discard;\n",L+="    }\n",L+="    gl_FragColor = vec4(color, 1.0);\n"):L+="BLEND"===K?"    gl_FragColor = vec4(color, baseColorWithAlpha.a);\n":"    gl_FragColor = vec4(color, 1.0);\n":L+="    gl_FragColor = vec4(color, 1.0);\n",L+="}\n";var he=Object(s["a"])(O,{type:a["a"].VERTEX_SHADER,extras:{_pipeline:{source:H,extension:".glsl"}}}),be=Object(s["a"])(O,{type:a["a"].FRAGMENT_SHADER,extras:{_pipeline:{source:L,extension:".glsl"}}}),Ce=Object(s["a"])(S,{fragmentShader:be,vertexShader:he}),Te=Object(s["a"])(y,{attributes:te,program:Ce,uniforms:q});return Te}function C(e){if(-1!==e.indexOf("Offset"))return a["a"].FLOAT_VEC2;if(-1!==e.indexOf("Rotation"))return a["a"].FLOAT;if(-1!==e.indexOf("Scale"))return a["a"].FLOAT_VEC2;if(-1!==e.indexOf("Texture"))return a["a"].SAMPLER_2D;switch(e){case"u_baseColorFactor":return a["a"].FLOAT_VEC4;case"u_metallicFactor":return a["a"].FLOAT;case"u_roughnessFactor":return a["a"].FLOAT;case"u_emissiveFactor":return a["a"].FLOAT_VEC3;case"u_diffuseFactor":return a["a"].FLOAT_VEC4;case"u_specularFactor":return a["a"].FLOAT_VEC3;case"u_glossinessFactor":return a["a"].FLOAT}}n["a"]=p},d3d4:function(e,n,t){"use strict";n["a"]="#ifdef INSTANCED\nattribute vec2 direction;\n#endif\nattribute vec4 positionHighAndScale;\nattribute vec4 positionLowAndRotation;\nattribute vec4 compressedAttribute0;                       // pixel offset, translate, horizontal origin, vertical origin, show, direction, texture coordinates (texture offset)\nattribute vec4 compressedAttribute1;                       // aligned axis, translucency by distance, image width\nattribute vec4 compressedAttribute2;                       // label horizontal origin, image height, color, pick color, size in meters, valid aligned axis, 13 bits free\nattribute vec4 eyeOffset;                                  // eye offset in meters, 4 bytes free (texture range)\nattribute vec4 scaleByDistance;                            // near, nearScale, far, farScale\nattribute vec4 pixelOffsetScaleByDistance;                 // near, nearScale, far, farScale\nattribute vec4 compressedAttribute3;                       // distance display condition near, far, disableDepthTestDistance, dimensions\nattribute vec2 sdf;                                        // sdf outline color (rgb) and width (w)\n#if defined(VERTEX_DEPTH_CHECK) || defined(FRAGMENT_DEPTH_CHECK)\nattribute vec4 textureCoordinateBoundsOrLabelTranslate;    // the min and max x and y values for the texture coordinates\n#endif\n#ifdef VECTOR_TILE\nattribute float a_batchId;\n#endif\n\nvarying vec2 v_textureCoordinates;\n#ifdef FRAGMENT_DEPTH_CHECK\nvarying vec4 v_textureCoordinateBounds;\nvarying vec4 v_originTextureCoordinateAndTranslate;\nvarying vec4 v_compressed;                                 // x: eyeDepth, y: applyTranslate & enableDepthCheck, z: dimensions, w: imageSize\nvarying mat2 v_rotationMatrix;\n#endif\n\nvarying vec4 v_pickColor;\nvarying vec4 v_color;\n#ifdef SDF\nvarying vec4 v_outlineColor;\nvarying float v_outlineWidth;\n#endif\n\nconst float UPPER_BOUND = 32768.0;\n\nconst float SHIFT_LEFT16 = 65536.0;\nconst float SHIFT_LEFT12 = 4096.0;\nconst float SHIFT_LEFT8 = 256.0;\nconst float SHIFT_LEFT7 = 128.0;\nconst float SHIFT_LEFT5 = 32.0;\nconst float SHIFT_LEFT3 = 8.0;\nconst float SHIFT_LEFT2 = 4.0;\nconst float SHIFT_LEFT1 = 2.0;\n\nconst float SHIFT_RIGHT12 = 1.0 / 4096.0;\nconst float SHIFT_RIGHT8 = 1.0 / 256.0;\nconst float SHIFT_RIGHT7 = 1.0 / 128.0;\nconst float SHIFT_RIGHT5 = 1.0 / 32.0;\nconst float SHIFT_RIGHT3 = 1.0 / 8.0;\nconst float SHIFT_RIGHT2 = 1.0 / 4.0;\nconst float SHIFT_RIGHT1 = 1.0 / 2.0;\n\nvec4 addScreenSpaceOffset(vec4 positionEC, vec2 imageSize, float scale, vec2 direction, vec2 origin, vec2 translate, vec2 pixelOffset, vec3 alignedAxis, bool validAlignedAxis, float rotation, bool sizeInMeters, out mat2 rotationMatrix, out float mpp)\n{\n    // Note the halfSize cannot be computed in JavaScript because it is sent via\n    // compressed vertex attributes that coerce it to an integer.\n    vec2 halfSize = imageSize * scale * 0.5;\n    halfSize *= ((direction * 2.0) - 1.0);\n\n    vec2 originTranslate = origin * abs(halfSize);\n\n#if defined(ROTATION) || defined(ALIGNED_AXIS)\n    if (validAlignedAxis || rotation != 0.0)\n    {\n        float angle = rotation;\n        if (validAlignedAxis)\n        {\n            vec4 projectedAlignedAxis = czm_modelViewProjection * vec4(alignedAxis, 0.0);\n            angle += sign(-projectedAlignedAxis.x) * acos(sign(projectedAlignedAxis.y) * (projectedAlignedAxis.y * projectedAlignedAxis.y) /\n                    (projectedAlignedAxis.x * projectedAlignedAxis.x + projectedAlignedAxis.y * projectedAlignedAxis.y));\n        }\n\n        float cosTheta = cos(angle);\n        float sinTheta = sin(angle);\n        rotationMatrix = mat2(cosTheta, sinTheta, -sinTheta, cosTheta);\n        halfSize = rotationMatrix * halfSize;\n    }\n    else\n    {\n        rotationMatrix = mat2(1.0, 0.0, 0.0, 1.0);\n    }\n#endif\n\n    mpp = czm_metersPerPixel(positionEC);\n    positionEC.xy += (originTranslate + halfSize) * czm_branchFreeTernary(sizeInMeters, 1.0, mpp);\n    positionEC.xy += (translate + pixelOffset) * mpp;\n\n    return positionEC;\n}\n\n#ifdef VERTEX_DEPTH_CHECK\nfloat getGlobeDepth(vec4 positionEC)\n{\n    vec4 posWC = czm_eyeToWindowCoordinates(positionEC);\n\n    float globeDepth = czm_unpackDepth(texture2D(czm_globeDepthTexture, posWC.xy / czm_viewport.zw));\n\n    if (globeDepth == 0.0)\n    {\n        return 0.0; // not on the globe\n    }\n\n    vec4 eyeCoordinate = czm_windowToEyeCoordinates(posWC.xy, globeDepth);\n    return eyeCoordinate.z / eyeCoordinate.w;\n}\n#endif\nvoid main()\n{\n    // Modifying this shader may also require modifications to Billboard._computeScreenSpacePosition\n\n    // unpack attributes\n    vec3 positionHigh = positionHighAndScale.xyz;\n    vec3 positionLow = positionLowAndRotation.xyz;\n    float scale = positionHighAndScale.w;\n\n#if defined(ROTATION) || defined(ALIGNED_AXIS)\n    float rotation = positionLowAndRotation.w;\n#else\n    float rotation = 0.0;\n#endif\n\n    float compressed = compressedAttribute0.x;\n\n    vec2 pixelOffset;\n    pixelOffset.x = floor(compressed * SHIFT_RIGHT7);\n    compressed -= pixelOffset.x * SHIFT_LEFT7;\n    pixelOffset.x -= UPPER_BOUND;\n\n    vec2 origin;\n    origin.x = floor(compressed * SHIFT_RIGHT5);\n    compressed -= origin.x * SHIFT_LEFT5;\n\n    origin.y = floor(compressed * SHIFT_RIGHT3);\n    compressed -= origin.y * SHIFT_LEFT3;\n\n#ifdef FRAGMENT_DEPTH_CHECK\n    vec2 depthOrigin = origin.xy;\n#endif\n    origin -= vec2(1.0);\n\n    float show = floor(compressed * SHIFT_RIGHT2);\n    compressed -= show * SHIFT_LEFT2;\n\n#ifdef INSTANCED\n    vec2 textureCoordinatesBottomLeft = czm_decompressTextureCoordinates(compressedAttribute0.w);\n    vec2 textureCoordinatesRange = czm_decompressTextureCoordinates(eyeOffset.w);\n    vec2 textureCoordinates = textureCoordinatesBottomLeft + direction * textureCoordinatesRange;\n#else\n    vec2 direction;\n    direction.x = floor(compressed * SHIFT_RIGHT1);\n    direction.y = compressed - direction.x * SHIFT_LEFT1;\n\n    vec2 textureCoordinates = czm_decompressTextureCoordinates(compressedAttribute0.w);\n#endif\n\n    float temp = compressedAttribute0.y  * SHIFT_RIGHT8;\n    pixelOffset.y = -(floor(temp) - UPPER_BOUND);\n\n    vec2 translate;\n    translate.y = (temp - floor(temp)) * SHIFT_LEFT16;\n\n    temp = compressedAttribute0.z * SHIFT_RIGHT8;\n    translate.x = floor(temp) - UPPER_BOUND;\n\n    translate.y += (temp - floor(temp)) * SHIFT_LEFT8;\n    translate.y -= UPPER_BOUND;\n\n    temp = compressedAttribute1.x * SHIFT_RIGHT8;\n    float temp2 = floor(compressedAttribute2.w * SHIFT_RIGHT2);\n\n    vec2 imageSize = vec2(floor(temp), temp2);\n\n#ifdef FRAGMENT_DEPTH_CHECK\n    float labelHorizontalOrigin = floor(compressedAttribute2.w - (temp2 * SHIFT_LEFT2));\n    float applyTranslate = 0.0;\n    if (labelHorizontalOrigin != 0.0) // is a billboard, so set apply translate to false\n    {\n        applyTranslate = 1.0;\n        labelHorizontalOrigin -= 2.0;\n        depthOrigin.x = labelHorizontalOrigin + 1.0;\n    }\n\n    depthOrigin = vec2(1.0) - (depthOrigin * 0.5);\n#endif\n\n#ifdef EYE_DISTANCE_TRANSLUCENCY\n    vec4 translucencyByDistance;\n    translucencyByDistance.x = compressedAttribute1.z;\n    translucencyByDistance.z = compressedAttribute1.w;\n\n    translucencyByDistance.y = ((temp - floor(temp)) * SHIFT_LEFT8) / 255.0;\n\n    temp = compressedAttribute1.y * SHIFT_RIGHT8;\n    translucencyByDistance.w = ((temp - floor(temp)) * SHIFT_LEFT8) / 255.0;\n#endif\n\n#if defined(VERTEX_DEPTH_CHECK) || defined(FRAGMENT_DEPTH_CHECK)\n    temp = compressedAttribute3.w;\n    temp = temp * SHIFT_RIGHT12;\n\n    vec2 dimensions;\n    dimensions.y = (temp - floor(temp)) * SHIFT_LEFT12;\n    dimensions.x = floor(temp);\n#endif\n\n#ifdef ALIGNED_AXIS\n    vec3 alignedAxis = czm_octDecode(floor(compressedAttribute1.y * SHIFT_RIGHT8));\n    temp = compressedAttribute2.z * SHIFT_RIGHT5;\n    bool validAlignedAxis = (temp - floor(temp)) * SHIFT_LEFT1 > 0.0;\n#else\n    vec3 alignedAxis = vec3(0.0);\n    bool validAlignedAxis = false;\n#endif\n\n    vec4 pickColor;\n    vec4 color;\n\n    temp = compressedAttribute2.y;\n    temp = temp * SHIFT_RIGHT8;\n    pickColor.b = (temp - floor(temp)) * SHIFT_LEFT8;\n    temp = floor(temp) * SHIFT_RIGHT8;\n    pickColor.g = (temp - floor(temp)) * SHIFT_LEFT8;\n    pickColor.r = floor(temp);\n\n    temp = compressedAttribute2.x;\n    temp = temp * SHIFT_RIGHT8;\n    color.b = (temp - floor(temp)) * SHIFT_LEFT8;\n    temp = floor(temp) * SHIFT_RIGHT8;\n    color.g = (temp - floor(temp)) * SHIFT_LEFT8;\n    color.r = floor(temp);\n\n    temp = compressedAttribute2.z * SHIFT_RIGHT8;\n    bool sizeInMeters = floor((temp - floor(temp)) * SHIFT_LEFT7) > 0.0;\n    temp = floor(temp) * SHIFT_RIGHT8;\n\n    pickColor.a = (temp - floor(temp)) * SHIFT_LEFT8;\n    pickColor /= 255.0;\n\n    color.a = floor(temp);\n    color /= 255.0;\n\n    ///////////////////////////////////////////////////////////////////////////\n\n    vec4 p = czm_translateRelativeToEye(positionHigh, positionLow);\n    vec4 positionEC = czm_modelViewRelativeToEye * p;\n\n#if defined(FRAGMENT_DEPTH_CHECK) || defined(VERTEX_DEPTH_CHECK)\n    float eyeDepth = positionEC.z;\n#endif\n\n    positionEC = czm_eyeOffset(positionEC, eyeOffset.xyz);\n    positionEC.xyz *= show;\n\n    ///////////////////////////////////////////////////////////////////////////\n\n#if defined(EYE_DISTANCE_SCALING) || defined(EYE_DISTANCE_TRANSLUCENCY) || defined(EYE_DISTANCE_PIXEL_OFFSET) || defined(DISTANCE_DISPLAY_CONDITION) || defined(DISABLE_DEPTH_DISTANCE)\n    float lengthSq;\n    if (czm_sceneMode == czm_sceneMode2D)\n    {\n        // 2D camera distance is a special case\n        // treat all billboards as flattened to the z=0.0 plane\n        lengthSq = czm_eyeHeight2D.y;\n    }\n    else\n    {\n        lengthSq = dot(positionEC.xyz, positionEC.xyz);\n    }\n#endif\n\n#ifdef EYE_DISTANCE_SCALING\n    float distanceScale = czm_nearFarScalar(scaleByDistance, lengthSq);\n    scale *= distanceScale;\n    translate *= distanceScale;\n    // push vertex behind near plane for clipping\n    if (scale == 0.0)\n    {\n        positionEC.xyz = vec3(0.0);\n    }\n#endif\n\n    float translucency = 1.0;\n#ifdef EYE_DISTANCE_TRANSLUCENCY\n    translucency = czm_nearFarScalar(translucencyByDistance, lengthSq);\n    // push vertex behind near plane for clipping\n    if (translucency == 0.0)\n    {\n        positionEC.xyz = vec3(0.0);\n    }\n#endif\n\n#ifdef EYE_DISTANCE_PIXEL_OFFSET\n    float pixelOffsetScale = czm_nearFarScalar(pixelOffsetScaleByDistance, lengthSq);\n    pixelOffset *= pixelOffsetScale;\n#endif\n\n#ifdef DISTANCE_DISPLAY_CONDITION\n    float nearSq = compressedAttribute3.x;\n    float farSq = compressedAttribute3.y;\n    if (lengthSq < nearSq || lengthSq > farSq)\n    {\n        positionEC.xyz = vec3(0.0);\n    }\n#endif\n\n    mat2 rotationMatrix;\n    float mpp;\n\n#ifdef DISABLE_DEPTH_DISTANCE\n    float disableDepthTestDistance = compressedAttribute3.z;\n#endif\n\n#ifdef VERTEX_DEPTH_CHECK\nif (lengthSq < disableDepthTestDistance) {\n    float depthsilon = 10.0;\n\n    vec2 labelTranslate = textureCoordinateBoundsOrLabelTranslate.xy;\n    vec4 pEC1 = addScreenSpaceOffset(positionEC, dimensions, scale, vec2(0.0), origin, labelTranslate, pixelOffset, alignedAxis, validAlignedAxis, rotation, sizeInMeters, rotationMatrix, mpp);\n    float globeDepth1 = getGlobeDepth(pEC1);\n\n    if (globeDepth1 != 0.0 && pEC1.z + depthsilon < globeDepth1)\n    {\n        vec4 pEC2 = addScreenSpaceOffset(positionEC, dimensions, scale, vec2(0.0, 1.0), origin, labelTranslate, pixelOffset, alignedAxis, validAlignedAxis, rotation, sizeInMeters, rotationMatrix, mpp);\n        float globeDepth2 = getGlobeDepth(pEC2);\n\n        if (globeDepth2 != 0.0 && pEC2.z + depthsilon < globeDepth2)\n        {\n            vec4 pEC3 = addScreenSpaceOffset(positionEC, dimensions, scale, vec2(1.0), origin, labelTranslate, pixelOffset, alignedAxis, validAlignedAxis, rotation, sizeInMeters, rotationMatrix, mpp);\n            float globeDepth3 = getGlobeDepth(pEC3);\n            if (globeDepth3 != 0.0 && pEC3.z + depthsilon < globeDepth3)\n            {\n                positionEC.xyz = vec3(0.0);\n            }\n        }\n    }\n}\n#endif\n\n    positionEC = addScreenSpaceOffset(positionEC, imageSize, scale, direction, origin, translate, pixelOffset, alignedAxis, validAlignedAxis, rotation, sizeInMeters, rotationMatrix, mpp);\n    gl_Position = czm_projection * positionEC;\n    v_textureCoordinates = textureCoordinates;\n\n#ifdef LOG_DEPTH\n    czm_vertexLogDepth();\n#endif\n\n#ifdef DISABLE_DEPTH_DISTANCE\n    if (disableDepthTestDistance == 0.0 && czm_minimumDisableDepthTestDistance != 0.0)\n    {\n        disableDepthTestDistance = czm_minimumDisableDepthTestDistance;\n    }\n\n    if (disableDepthTestDistance != 0.0)\n    {\n        // Don't try to \"multiply both sides\" by w.  Greater/less-than comparisons won't work for negative values of w.\n        float zclip = gl_Position.z / gl_Position.w;\n        bool clipped = (zclip < -1.0 || zclip > 1.0);\n        if (!clipped && (disableDepthTestDistance < 0.0 || (lengthSq > 0.0 && lengthSq < disableDepthTestDistance)))\n        {\n            // Position z on the near plane.\n            gl_Position.z = -gl_Position.w;\n#ifdef LOG_DEPTH\n            czm_vertexLogDepth(vec4(czm_currentFrustum.x));\n#endif\n        }\n    }\n#endif\n\n#ifdef FRAGMENT_DEPTH_CHECK\n    if (sizeInMeters) {\n        translate /= mpp;\n        dimensions /= mpp;\n        imageSize /= mpp;\n    }\n\n#if defined(ROTATION) || defined(ALIGNED_AXIS)\n    v_rotationMatrix = rotationMatrix;\n#else\n    v_rotationMatrix = mat2(1.0, 0.0, 0.0, 1.0);\n#endif\n\n    float enableDepthCheck = 0.0;\n    if (lengthSq < disableDepthTestDistance)\n    {\n        enableDepthCheck = 1.0;\n    }\n\n    float dw = floor(clamp(dimensions.x, 0.0, SHIFT_LEFT12));\n    float dh = floor(clamp(dimensions.y, 0.0, SHIFT_LEFT12));\n\n    float iw = floor(clamp(imageSize.x, 0.0, SHIFT_LEFT12));\n    float ih = floor(clamp(imageSize.y, 0.0, SHIFT_LEFT12));\n\n    v_compressed.x = eyeDepth;\n    v_compressed.y = applyTranslate * SHIFT_LEFT1 + enableDepthCheck;\n    v_compressed.z = dw * SHIFT_LEFT12 + dh;\n    v_compressed.w = iw * SHIFT_LEFT12 + ih;\n    v_originTextureCoordinateAndTranslate.xy = depthOrigin;\n    v_originTextureCoordinateAndTranslate.zw = translate;\n    v_textureCoordinateBounds = textureCoordinateBoundsOrLabelTranslate;\n\n#endif\n\n#ifdef SDF\n    vec4 outlineColor;\n    float outlineWidth;\n\n    temp = sdf.x;\n    temp = temp * SHIFT_RIGHT8;\n    outlineColor.b = (temp - floor(temp)) * SHIFT_LEFT8;\n    temp = floor(temp) * SHIFT_RIGHT8;\n    outlineColor.g = (temp - floor(temp)) * SHIFT_LEFT8;\n    outlineColor.r = floor(temp);\n\n    temp = sdf.y;\n    temp = temp * SHIFT_RIGHT8;\n    float temp3 = (temp - floor(temp)) * SHIFT_LEFT8;\n    temp = floor(temp) * SHIFT_RIGHT8;\n    outlineWidth = (temp - floor(temp)) * SHIFT_LEFT8;\n    outlineColor.a = floor(temp);\n    outlineColor /= 255.0;\n\n    v_outlineWidth = outlineWidth / 255.0;\n    v_outlineColor = outlineColor;\n#endif\n\n    v_pickColor = pickColor;\n\n    v_color = color;\n    v_color.a *= translucency;\n\n}\n"},d3f9:function(e,n,t){"use strict";n["a"]="varying vec4 v_color;\n\nvoid main()\n{\n    gl_FragColor = czm_gammaCorrect(v_color);\n}\n"},f533:function(e,n,t){"use strict";n["a"]="varying vec3 v_positionEC;\nvarying vec3 v_normalEC;\nvarying vec4 v_color;\n\nvoid main()\n{\n    vec3 positionToEyeEC = -v_positionEC;\n\n    vec3 normalEC = normalize(v_normalEC);\n#ifdef FACE_FORWARD\n    normalEC = faceforward(normalEC, vec3(0.0, 0.0, 1.0), -normalEC);\n#endif\n\n    vec4 color = czm_gammaCorrect(v_color);\n\n    czm_materialInput materialInput;\n    materialInput.normalEC = normalEC;\n    materialInput.positionToEyeEC = positionToEyeEC;\n    czm_material material = czm_getDefaultMaterial(materialInput);\n    material.diffuse = color.rgb;\n    material.alpha = color.a;\n\n    gl_FragColor = czm_phong(normalize(positionToEyeEC), material, czm_lightDirectionEC);\n}\n"}}]);